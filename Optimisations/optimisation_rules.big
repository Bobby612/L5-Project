## Optimisations expressed as graph rewriting rules

## # Common Node Elimination

fun react opt_common_node_elimination_2_comm(s) = 
    Node.(
        NodeType.Simple | 
        Body.Instruction(s) |
        Read.(Dedge{x}.id | Dedge{y}.id) |
        Write.Dedge{z}.id |
        id
    ) | 
    Node.(
        NodeType.Simple |
        Body.Instruction(s) |
        Read.(Dedge{x}.id | Dedge{y}.id) |
        Write.Dedge{w}.id |
        id
    ) 
    --> /u
    Node.(
        NodeType.Simple |
        Body.Instruction(s) |
        Read.(Dedge{x}.id | Dedge{y}.id) |
        Write.Dedge{u}.id |
        Alias{z,w}.AliasNewName{u} |
        id
    ) 
    @[0, 1, 2, 3];

fun react opt_common_node_eimination_const(t,c) = ## NB: Datatypes for constants are currently not implemented
    /a
    Node.(
        NodeType.Simple |
        Body.Literal |
        Read.1 |
        Write.Dedge{x}.Loc{a} |
        Extra.DataTypes.(Loc1{a}.DataType(0,t) | Loc1{a}.Const(c) )
    ) | /b
    Node.(
        NodeType.Simple |
        Body.Literal |
        Read.1 |
        Write.Dedge{y}.Loc{b} |
        Extra.DataTypes.(Loc1{a}.DataType(0,t) | Loc1{a}.Const(c) )
    )
    -->
    /a
    Node.(
        NodeType.Simple |
        Body.Literal |
        Read.1 |
        Write.Dedge{u}.Loc{a} |
        Extra.DataTypes.(Loc1{a}.DataType(0,t) | Loc1{a}.Const(c) )
    ) |
    Alias{x,y}.AliasNewName{u}
    ;


## # Node Pull In -- Gamma
fun react opt_node_pull_in(i) = /x /b (
    Node.(
        Read.id |
        Write.Dedge{x}.id |
        id
    ) |
    Node.(
        NodeType.Gamma |
        Read.(Dedge{x}.Loc{b} | id) | 
        Import.(Dedge{y}.Loc{b} | id) |
        Body.(
            Region(i).(
                Node.(
                    Read.(Dedge{y}.id | id) |
                    id
                ) |
                id
            ) |
            id
        ) | 
        id
    )
)
    --> 
    Node.(
        NodeType.Gamma |
        Read.(id | id) | 
        Import.(id | id) |
        Body.(
            Region(i).(
                Node.(
                    Read.id |
                    Write.Dedge{y}.id | 
                    id
                ) |
                Node.(
                    Read.(Dedge{y}.id | id) |
                    id
                ) |
                id
            ) |
            id
        ) |
        id
    )
    @[0, 3, 0, 4, 0, 1, 2, 5, 6, 7, 8, 9, 10]
    ;


## # Node Push Out -- Theta Node
react opt_node_pushout_theta_2_read = /a /b
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | id) | 
        Body.Region(0).(
            Node.(
                Read.(Dedge{x}.id | Dedge{y}.id) |
                Write.Dedge{z}.id |
                id
            ) | 
            id
        ) |
        id
    )
    --> /o (
    Node.(
        Read.(Dedge{m}.id | Dedge{n}.id) |
        Write.Dedge{o}.id |
        id
    ) | /c /a /b
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | Dedge{o}.Loc{c} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | Dedge{z}.Loc{c} | id ) | 
        Body.Region(0).id |
        id
    )
)
    @[2, 3, 4, 5, 0, 1, 6, 7]
    ## if !({a} || {b}) in param
    ;

react opt_node_pushout_theta_1_read = /a
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | id) |
        Import.(Dedge{x}.Loc{a} | id) | 
        Body.Region(0).(
            Node.(
                Read.Dedge{x}.id |
                Write.Dedge{z}.id |
                id
            ) | 
            id
        ) |
        id
    )
    --> /o (
    Node.(
        Read.Dedge{m}.id|
        Write.Dedge{o}.id |
        id
    ) | /c /a
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | Dedge{o}.Loc{c} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{z}.Loc{c} | id ) | 
        Body.Region(0).id |
        id
    )
)
    @[2, 3, 4, 0, 1, 5, 6]
    ## if !Loc{a} in param
    ;
    

react opt_node_pushout_theta_store = /a /b  ## Store is idempotent, so doing it once or doing it multiple times is the same if the arguments are the same
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | Dedge{o}.Loc{c} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | Dedge{z}.Loc{c} | id) | 
        Body.Region(0).(
            Node.(
                Body.Instruction("Store") |
                Read.(Dedge{x}.id | Dedge{y}.id | Dedge{z}.Loc{d}) |
                Extra.(DataTypes.(Loc1{d}.State | id) | id )|
                Write.Dedge{w}.Loc{d} |
                id
            ) | 
            id
        ) |
        id
    )
    --> /p (
    Node.(
        Body.Instruction("Store") |
        Read.(Dedge{m}.id | Dedge{n}.id | Dedge{o}.Loc{d}) |
        Extra.(DataTypes.(Loc1{d}.State | id) | id )|
        Write.Dedge{p}.Loc{d} |
        id
    ) | /a /b /e
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | Dedge{o}.Loc{c} | Dedge{p}.Loc{e} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | Dedge{z}.Loc{c} | Dedge{w}.Loc{e} | id) | 
        Body.Region(0).id |
        id
    )
)
    @[2, 3, 4, 5, 6, 0, 1, 7, 8]
    ## if !({a} || {b}) in param
    ;

## # Node Push Out -- Gamma Node
fun react opt_node_pushout_2_gamma_2_comm(s) = 
    Node.(
        NodeType.Gamma |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | id) |
        Import.(Dedge{q}.Loc{a} | Dedge{r}.Loc{b} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | id) |
        Body.(
            Region(1).(
                Node.(
                    Body.Instruction(s) |
                    Read.(Dedge{q}.id | Dedge{r}.id) |
                    Write.Dedge{t}.id |
                    id
                ) | 
                id
            ) |
            Region(2).(
                Node.(
                    Body.Instruction(s) | 
                    Read.(Dedge{x}.id | Dedge{y}.id) |
                    Write.Dedge{z}.id |
                    id
                ) |
                id
            )
        ) |
        id
    )
    --> 
    /p (
    Node.(
        Body.Instruction(s) |
        Read.(Dedge{m}.id | Dedge{n}.id) |
        Write.Dedge{p}.id |
        id
    ) | /d
    Node.(
        NodeType.Gamma |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | Dedge{p}.Loc{d} | id) |
        Import.(Dedge{q}.Loc{a} | Dedge{r}.Loc{b} | Dedge{t}.Loc{d} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | Dedge{z}.Loc{d} |id) |
        Body.(
            Region(1).id |
            Region(2).id
        ) |
        id
    )
)
    @[3, 4, 5, 6, 0, 1, 2, 7, 12, 13]
    ;

fun react opt_node_pushout_2_gamma_3_comm(s) = 
    Node.(
        NodeType.Gamma |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | Dedge{o}.Loc{c} | id) |
        Import.(Dedge{q}.Loc{a} | Dedge{r}.Loc{b} | Dedge{s}.Loc{c} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | Dedge{z}.Loc{c} | id) |
        Body.(
            Region(1).(
                Node.(
                    Body.Instruction(s) |
                    Read.(Dedge{q}.id | Dedge{r}.id | Dedge{s}.id) |
                    Write.Dedge{t}.id |
                    id
                ) | 
                id
            ) |
            Region(2).(
                Node.(
                    Body.Instruction(s) | 
                    Read.(Dedge{x}.id | Dedge{y}.id | Dedge{z}.id) |
                    Write.Dedge{w}.id |
                    id
                ) |
                id
            )
        ) |
        id
    )
    --> 
    /p (
    Node.(
        Body.Instruction(s) |
        Read.(Dedge{m}.id | Dedge{n}.id | Dedge{o}.id) |
        Write.Dedge{p}.id |
        id
    ) | /d
    Node.(
        NodeType.Gamma |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | Dedge{o}.Loc{c} | Dedge{p}.Loc{d} | id) |
        Import.(Dedge{q}.Loc{a} | Dedge{r}.Loc{b} | Dedge{s}.Loc{c} | Dedge{t}.Loc{d} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | Dedge{z}.Loc{c} | Dedge{w}.Loc{d} | id) |
        Body.(
            Region(1).id |
            Region(2).id
        ) |
        id
    )
)
    @[3, 4, 5, 6, 7, 0, 1, 2, 8, 14, 15]
    ;


## # Invariant Value Redirection -- actually
react opt_invariant_value_redirection_theta = /y 
    Node.(
        Read.(Dedge{x}.Loc{a} | id) |
        Import.(Dedge{y}.Loc{a} | id) |
        Export.(Dedge{y}.Loc{b} | id) |
        Write.(Dedge{z}.Loc{b} | id) |
        id
    )
    --> /u
    Alias{x,z}.AliasNewName{u} |
    Node.(
        Read.(Dedge{x}.Loc{a} | id) |
        Import.id |
        Export.id |
        Write.(Dedge{z}.Loc{b} | id) |
        id
    )
    ;



## Some fix rules 
react opt_fix_remove_unused_read = ## Used in IVR 
    /a 
    Node.(
        Read.(Dedge{x}.Loc{a} | id) |
        id
    )
    -->
    {x} |
    Node.(
        Read.id |
        id
    )
    if !Simple in param
    ;

react opt_fix_remove_unused_write = ## Used in IVR 
    /a 
    Node.(
        Write.(Dedge{x}.Loc{a} | id) |
        id
    )
    -->
    {x} |
    Node.(
        Write.id |
        id
    )
    if !Simple in param
    ;


react opt_fix_consolidate_read = 
    Node.(
        Read.(Dedge{x}.Loc{a} | Dedge{x}.Loc{b} | id) |
        id
    ) 
    --> /u
    Node.(
        Read.(Dedge{x}.Loc{u} |  Alias{a,b}.AliasNewName{u} | id) |
        id
    ) 
    ;


react opt_fix_remove_unused_import = /y /a
    Node.(
        Read.(Dedge{x}.Loc{a} | id) |
        Import.(Dedge{y}.Loc{a} | id) |
        id
    )
    -->
    Node.(
        Read.id |
        Import.id |
        id
    ) | {x}
    ;

fun react opt_fix_gamma_read(i) = 
    Node.(
        NodeType.Gamma |
        Read.(Dedge{x}.Loc{a} | id) |
        Import.(Dedge{x}.Loc{a} | id) |
        Body.(
            Region(i).(
                Node.(
                    Read.(Dedge{x}.Loc{a}  | id) |
                    id
                ) |
                id
            ) | 
            id
        ) |
        id
    )
    --> /b /y
    Node.(
        NodeType.Gamma |
        Read.(Dedge{x}.Loc{b} | id) |
        Import.(Dedge{y}.Loc{b} | id) |
        Body.(
            Region(i).(
                Node.(
                    Read.(Dedge{y}.Loc{a}  | id) |
                    id
                ) |
                id
            ) |
            id
        ) |
        id
    )
    ;

react opt_deduplicate_import_read = /b (
    Read.(Dedge{z}.Loc{a} | Dedge{z}.Loc{b} | id) |
    Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | id) 
)
    --> /u (
    Read.(Dedge{z}.Loc{a} | id) |
    Import.(Dedge{u}.Loc{a} | Alias{x,y}.AliasNewName{u}| id)
)
    ;


# ## ## Misc ## ## #
## Aliasing fixes
react aliasing_connect = 
    Alias{x,y}.AliasNewName{u} || 
    Dedge{x}.id
    -->
    Alias{x,y}.AliasNewName{u} ||
    Dedge{u}.id
    ;

react aliasing_finish = /x /y
    Alias{x,y}.AliasNewName{u}
    -->
    1 | {u}
    ;


