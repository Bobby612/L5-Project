## Optimisations expressed as graph rewriting rules

## # Common Node Elimination

fun react opt_common_node_elimination_2_comm(s) = 
    Node.(
        NodeType.Simple | 
        Body.Instruction(s) |
        Read.(Dedge{x}.id | Dedge{y}.id) |
        Write.Dedge{z}.id |
        id
    ) | 
    Node.(
        NodeType.Simple |
        Body.Instruction(s) |
        Read.(Dedge{x}.id | Dedge{y}.id) |
        Write.Dedge{w}.id |
        id
    ) 
    --> /u
    Node.(
        NodeType.Simple |
        Body.Instruction(s) |
        Read.(Dedge{x}.id | Dedge{y}.id) |
        Write.Dedge{u}.id |
        Alias{z,w}.AliasNewName{u} |
        id
    ) 
    @[0, 1, 2, 3];

fun react opt_common_node_eimination_const(t,c) = ## NB: Datatypes for constants are currently not implemented
    /a
    Node.(
        NodeType.Simple |
        Body.Literal |
        Read.1 |
        Write.Dedge{x}.Loc{a} |
        Extra.DataTypes.(Loc1{a}.DataType(0,t) | Loc1{a}.Const(c) )
    ) | /b
    Node.(
        NodeType.Simple |
        Body.Literal |
        Read.1 |
        Write.Dedge{y}.Loc{b} |
        Extra.DataTypes.(Loc1{a}.DataType(0,t) | Loc1{a}.Const(c) )
    )
    -->
    /a
    Node.(
        NodeType.Simple |
        Body.Literal |
        Read.1 |
        Write.Dedge{u}.Loc{a} |
        Extra.DataTypes.(Loc1{a}.DataType(0,t) | Loc1{a}.Const(c) )
    ) |
    Alias{x,y}.AliasNewName{u}
    ;


## # Node Pull In -- Gamma
fun react opt_node_pull_in(i) = /x /b (
    Node.(
        Read.id |
        Write.Dedge{x}.id |
        id
    ) |
    Node.(
        NodeType.Gamma |
        Read.(Dedge{x}.Loc{b} | id) | 
        Import.(Dedge{y}.Loc{b} | id) |
        Body.(
            Region(i).(
                Node.(
                    Read.(Dedge{y}.id | id) |
                    id
                ) |
                id
            ) |
            id
        ) | 
        id
    )
)
    --> 
    Node.(
        NodeType.Gamma |
        Read.(id | id) | 
        Import.(id | id) |
        Body.(
            Region(i).(
                Node.(
                    Read.id |
                    Write.Dedge{y}.id | 
                    id
                ) |
                Node.(
                    Read.(Dedge{y}.id | id) |
                    id
                ) |
                id
            ) |
            id
        ) |
        id
    )
    @[0, 3, 0, 4, 0, 1, 2, 5, 6, 7, 8, 9, 10]
    ;


## # Node Push Out -- Theta Node
react opt_node_pushout_theta_2_read = /a /b
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | id) | 
        Body.Region(0).(
            Node.(
                Read.(Dedge{x}.id | Dedge{y}.id) |
                Write.Dedge{z}.id |
                id
            ) | 
            id
        ) |
        id
    )
    --> /o (
    Node.(
        Read.(Dedge{m}.id | Dedge{n}.id) |
        Write.Dedge{o}.id |
        id
    ) | /c /a /b
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | Dedge{n}.Loc{b} | Dedge{o}.Loc{c} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | Dedge{z}.Loc{c} | id ) | 
        Body.Region(0).id |
        id
    )
)
    @[2, 3, 4, 5, 0, 1, 6, 7]
    ## if !({a} || {b}) in param
    ;

react opt_node_pushout_theta_1_read = /a
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | id) |
        Import.(Dedge{x}.Loc{a} | id) | 
        Body.Region(0).(
            Node.(
                Read.Dedge{x}.id |
                Write.Dedge{z}.id |
                id
            ) | 
            id
        ) |
        id
    )
    --> /o (
    Node.(
        Read.Dedge{m}.id|
        Write.Dedge{o}.id |
        id
    ) | /c /a
    Node.(
        NodeType.Theta |
        Read.(Dedge{m}.Loc{a} | Dedge{o}.Loc{c} | id) |
        Import.(Dedge{x}.Loc{a} | Dedge{z}.Loc{c} | id ) | 
        Body.Region(0).id |
        id
    )
)
    @[2, 3, 4, 0, 1, 5, 6]
    ## if !Loc{a} in param
    ;


## Some fix rules 
react opt_fix_remove_unused_import = /y /a
    Node.(
        Read.(Dedge{x}.Loc{a} | id) |
        Import.(Dedge{y}.Loc{a} | id) |
        id
    )
    -->
    Node.(
        Read.id |
        Import.id |
        id
    ) | {x}
    ;

fun react opt_fix_gamma_read(i) = 
    Node.(
        NodeType.Gamma |
        Read.(Dedge{x}.Loc{a} | id) |
        Import.(Dedge{x}.Loc{a} | id) |
        Body.(
            Region(i).(
                Node.(
                    Read.(Dedge{x}.Loc{a}  | id) |
                    id
                ) |
                id
            ) | 
            id
        ) |
        id
    )
    --> /b /y
    Node.(
        NodeType.Gamma |
        Read.(Dedge{x}.Loc{b} | id) |
        Import.(Dedge{y}.Loc{b} | id) |
        Body.(
            Region(i).(
                Node.(
                    Read.(Dedge{y}.Loc{a}  | id) |
                    id
                ) |
                id
            ) |
            id
        ) |
        id
    )
    ;

react opt_deduplicate_import_read = /b (
    Read.(Dedge{z}.Loc{a} | Dedge{z}.Loc{b} | id) |
    Import.(Dedge{x}.Loc{a} | Dedge{y}.Loc{b} | id) 
)
    --> /u (
    Read.(Dedge{z}.Loc{a} | id) |
    Import.(Dedge{u}.Loc{a} | Alias{x,y}.AliasNewName{u}| id)
)
    ;


# ## ## Misc ## ## #
## Aliasing fixes
react aliasing_connect = 
    Alias{x,y}.AliasNewName{u} || 
    Dedge{x}.id
    -->
    Alias{x,y}.AliasNewName{u} ||
    Dedge{u}.id
    ;

react aliasing_finish = /x /y
    Alias{x,y}.AliasNewName{u}
    -->
    1 | {u}
    ;


