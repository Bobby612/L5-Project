

## Transform Control Flow Graph to Control Tree
react ct_begin = 
    Node.(
        NodeType.Lambda |
        Body.Region(0).( ## Function is non-empty and has CFG in it
            Block.id | id
        ) |
        id
    )   
    -->
    Node.(
        NodeType.Lambda |
        Body.Region(0).( 
            Block.id | id | Ct.1
        ) |
        id
    )
    if !Ct in param
    ;

react ct_continuous = /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{y} 
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            id
        ) |
        id
    ) |
    Ct.id 
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            id
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtContinuous |

            CtBlock(1).Block.id |
            CtBlock(2).Block.id |

            CtAbstract{a}
        ) |
        id
    ) 
)
    @[1, 0, 2, 3];

react ct_if_then_else = /y /z (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(1){y} | BlockExit_ord(2){z}
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{w} 
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{z} |
            BlockExit{w} 
        ) |
        id
    ) |
    Ct.id 
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{w} 
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtIfThenElse |

            CtBlock(0).Block.id |
            CtBlock(1).Block.id |
            CtBlock(2).Block.id |
            
            CtAbstract{a}
        ) |
        id
    ) 
)
    ;

fun react ct_if_then(i, j) = /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){y} | BlockExit_ord(j){z}
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{z}
        ) |
        id
    ) |
    Ct.id
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{z}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtIfThen |
            CtBlock(0).Block.id |
            CtBlock(1).Block.id |
            CtAbstract{a}
        ) |
        id
    )
)
    ;

fun react ct_selfloop(i, j) = ## The self-loop can be either the first or the second exit
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){x} | BlockExit_ord(j){y}
        ) |
        id
    ) |
    Ct.id
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} | BlockExit{y}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtSelfLoop |

            CtBlock(0).Block.id |
            
            CtAbstract{a}
        ) |
        id
    ) 
)
    ;

fun react ct_while_loop(i, j) =  /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){y} | BlockExit_ord(j){z}
        ) | 
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{x}
        ) |
        id
    ) |
    Ct.id
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{z}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtWhileLoop |
            
            CtBlock(0).Block.id |
            CtBlock(1).Block.id |

            CtAbstract{a}
        ) |
        id
    )
)
    ;

react ct_top_node = /x (
    Block.(
        Interface.BlockEntry{x} | 
        id
    ) | 
    Ct.id
)
    -->
    1 |
    Ct.(
        CtNode.(
            CtTopNode |
            CtBlock(0).Block.id
        ) | 
        id
    )
    ;

fun react ct_deabstractify(i) = /a (
    CtNode.(
        CtBlock(i).Block.CtAbstract{a} |
        id
    ) ||
    CtNode.(
        id |
        CtAbstract{a}
    )
)
    -->
    CtNode.(
        id |
        CtBlock(i).CtNode.id
    ) ||
    1
    ;


## Transform the Control Tree to RVSDG

## fun react rg_continuous_connect1_adr(i) = 
##     CtNode.(
##         CtContinuous |

##         CtBlock(1).Block.(
##             id |
##             Body.Region(0).id |
##             Export.(Adr(i){x} | id) 
##         ) |
##         CtBlock(2).Block.(
##             Import.(Adr(i){y} | id) |
##             id
##         )

##     )
##     -->
##     CtNode.(
##         CtContinuous |

##         CtBlock(1).Block.(
##             id |
##             Body.Region(0).(Shoelace{x,y} | id) |
##             Export.id
##         ) |
##         CtBlock(2).Block.(
##             Import.id |
##             id
##         )
##     )
    ## ;

## react rg_if_then_else = 
##     CtNode.(
##         CtIfThenElse |

##         CtBlock(0).Block.id |
##         CtBlock(1).Block.(Import.id | Export.id | Body.id) |
##         CtBlock(2).Block.(Import.id | Export.id | Body.id) 
##     )
##     -->
##     CtNode.(
##         CtIfThenElse |

##         CtBlock(0).Block.id |
##         Node.(
##             NodeType.Gamma |
##             Read.1 |
##             Import.id | Import.id | ## Import
##             Body.(
##                 id | id
##             ) |
##             Export.id | Export.id  | ## Export
##             Write.1
##         )
##     )
##     @[0, 1, 4, 3, 6, 2, 5]
##     if !CtNode in param
##     ;

    react rg_if_then_else = 
    CtNode.(
        CtIfThenElse |

        CtBlock(0).Block.id |
        CtBlock(1).Block.(Import.id | Export.id | Body.id) |
        CtBlock(2).Block.(Import.id | Export.id | Body.id) 
    )
    -->
    CtNode.(
        CtIfThenElse |

        CtBlock(0).Block.id |
        Node.(
            NodeType.Gamma |
            Read.(id | id) |
            Import.id | Import.id | ## Import
            Body.(
                id | id
            ) |
            Export.id | Export.id  | ## Export
            Write.(id | id)
        )
    )
    @[0, 1, 4, 1, 4, 3, 6, 2, 5, 2, 5]
    if !CtNode in param
    ;

## Add the read and write of the new node
## react rg_add_read = 
##     Node.(
##         Read.id |
##         Import.(Dedge{x}.Loc{y} | id) |
##         id
##     )
##     --> /z
##     Node.(
##         Read.(Dedge{z}.Loc{y} | id) |
##         Import.(Dedge{x}.Loc{y} | id) |
##         id 
##     )
##     if !{y} in param
##     ;

react rg_deduplicate_read = 
    Node.(
        Read.(Dedge{x}.Loc{y} | Dedge{z}.Loc{y} | id) |
        id
    )
    --> /w
    Node.(
        Read.(Dedge{w}.Loc{y} | id) |
        id |
        {x} | {z} 
    ) 
    ;

react rg_deduplicate_write = 
    Node.(
        Write.(Dedge{x}.Loc{y} | Dedge{z}.Loc{y} | id) |
        id
    )
    --> /w
    Node.(
        Write.(Dedge{w}.Loc{y} | id) |
        id |
        {x} | {z} 
    ) 
    ;

react rg_disconnect_dedge_read = ## Includes State
    Node.(
        Read.(Dedge{x}.Loc{y} | id) |
        Import.(Dedge{x}.Loc{y} | id) |
        id
    )
    --> /z
    Node.(
        Read.(Dedge{z}.Loc{y} | id) |
        Import.(Dedge{x}.Loc{y} | id) |
        id
    )
    ;

react rg_disconnect_dedge_write = ## includes State
    Node.(
        Write.(Dedge{x}.id | id) |
        Export.(Dedge{x}.id | id) |
        id
    )
    --> /z
    Node.(
        Write.(Dedge{z}.id | id) |
        Export.(Dedge{x} | id) |
        id
    )
    ;

react rg_deduplicate_state_read = /x /y
    Read.(Dedge{x}.State | Dedge{y}.State | id)
    --> /x
    Read.(Dedge{x}.State | id)
    ;

react rg_deduplicate_state_write = /x /y
    Write.(Dedge{x}.State | Dedge{y}.State | id)
    --> /x
    Write.(Dedge{x}.State | id)
    ;
    
    




