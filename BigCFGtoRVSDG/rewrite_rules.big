

## Transform Control Flow Graph to Control Tree
react ct_begin = 
    Node.(
        NodeType.Lambda |
        Body.Region(0).( ## Function is non-empty and has CFG in it
            Block.id | id
        ) |
        id
    )   
    -->
    Node.(
        NodeType.Lambda |
        Body.Region(0).( 
            Block.id | id | Ct.1
        ) |
        id
    )
    if !Ct in param
    ;

react ct_continuous = /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{y} 
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            id
        ) |
        id
    ) |
    Ct.id 
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            id
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtContinuous |

            CtBlock(1).Block.id |
            CtBlock(2).Block.id |

            CtAbstract{a}
        ) |
        id
    ) 
)
    @[1, 0, 2, 3];

react ct_if_then_else = /y /z (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(1){y} | BlockExit_ord(2){z}
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{w} 
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{z} |
            BlockExit{w} 
        ) |
        id
    ) |
    Ct.id 
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{w} 
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtIfThenElse |

            CtBlock(0).Block.id |
            CtBlock(1).Block.id |
            CtBlock(2).Block.id |
            
            CtAbstract{a}
        ) |
        id
    ) 
)
    ;

fun react ct_if_then(i, j) = /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){y} | BlockExit_ord(j){z}
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{z}
        ) |
        id
    ) |
    Ct.id
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{z}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtIfThen |
            CtBlock(0).Block.id |
            CtBlock(1).Block.id |
            CtAbstract{a}
        ) |
        id
    )
)
    ;

fun react ct_selfloop(i, j) = ## The self-loop can be either the first or the second exit
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){x} | BlockExit_ord(j){y}
        ) |
        id
    ) |
    Ct.id
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} | BlockExit{y}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtSelfLoop |

            CtBlock(0).Block.id |
            
            CtAbstract{a}
        ) |
        id
    ) 
)
    ;

fun react ct_while_loop(i, j) =  /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){y} | BlockExit_ord(j){z}
        ) | 
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{x}
        ) |
        id
    ) |
    Ct.id
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{z}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtIfThen |
            
            CtBlock(0).Block.id |
            CtBlock(1).CtNode.(
                CtSelfLoop |
                CtBlock(0).CtNode.(
                    CtContinuous |
                    CtBlock(1).Block.id |
                    CtBlock(2).Block.id 
                )
            ) |

            CtAbstract{a}
        ) |
        id
    )
)
    @[0, 1, 0, 2];

react ct_top_node = /x (
    Block.(
        Interface.BlockEntry{x} | 
        id
    ) | 
    Ct.id
)
    -->
    1 |
    Ct.(
        CtNode.(
            CtTopNode |
            CtBlock(0).Block.id
        ) | 
        id
    )
    ;

fun react ct_deabstractify(i) = /a (
    CtNode.(
        CtBlock(i).Block.CtAbstract{a} |
        id
    ) ||
    CtNode.(
        id |
        CtAbstract{a}
    )
)
    -->
    CtNode.(
        id |
        CtBlock(i).CtNode.id
    ) ||
    1
    ;


## Transform the Control Tree to RVSDG

react rg_continuous = 
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.id |
        CtBlock(2).Block.id 
    )
    -->
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.id |
        CtBlock(2).Block.id |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).1
        )
    )
    ;

react rg_continuous_finish_block = 
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Import.id |
            Export.id |
            Body.Region(0).id
        ) |
        CtBlock(2).Block.(
            Import.id |
            Export.id |
            Body.Region(0).id
        ) |
        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).id
        )
    )
    -->
    Block.(
        Import.(id | id) |
        Export.(id | id) |
        Body.Region(0).(id | id | id)
    )
    @[0, 3, 1, 4, 2, 5, 6];

react rg_if_then = 
    CtNode.(
        CtIfThen |

        CtBlock(0).Block.id |
        CtBlock(1).Block.(Import.id | Export.id | Body.id)
    )
    -->
    CtNode.(
        CtIfThen |

        CtBlock(0).Block.id |
        Node.(
            NodeType.Gamma |
            Read.id |
            Import.id | ## Import
            Body.id |
            Export.id  | ## Export
            Write.id |
            Extra.1
        )
    )
    @[0, 1, 1, 3, 2, 2]
    if !CtNode in param
    ;


react rg_if_then_else = 
    CtNode.(
        CtIfThenElse |

        CtBlock(0).Block.id |
        CtBlock(1).Block.(Import.id | Export.id | Body.id) |
        CtBlock(2).Block.(Import.id | Export.id | Body.id) 
    )
    -->
    CtNode.(
        CtIfThenElse |

        CtBlock(0).Block.id |
        Node.(
            NodeType.Gamma |
            Read.(id | id) |
            Import.id | Import.id | ## Import
            Body.(
                id | id
            ) |
            Export.id | Export.id  | ## Export
            Write.(id | id)
        )
    )
    @[0, 1, 4, 1, 4, 3, 6, 2, 5, 2, 5]
    if !CtNode in param
    ;

react rg_gamma_connect_conditional = 
    CtNode.(
        id |
        CtBlock(0).Block.(
            Body.Region(0).(
                Node.(
                    Body.Br |
                    Write.1 |
                    id
                ) |
                id
            ) |
            id
        ) |
        Node.(
            NodeType.Gamma |
            Read.id |
            id
        )
    ) 
    --> /x (
    CtNode.(
        id |
        CtBlock(0).Block.(
            Body.Region(0).(
                Node.(
                    Body.Br |
                    Write.Dedge{x}.Branch |
                    id
                ) |
                id
            ) | 
            id
        ) |
        Node.(
            NodeType.Gamma |
            Read.(
                Dedge{x}.Branch |
                id
            ) |
            id
        )
    )
)
    ;

react rg_self_loop = 
    CtNode.(
        CtSelfLoop |
        CtBlock(0).Block.(Import.id | Export.id | Body.Region(0).id)
    )
    -->
    CtNode.(
        CtSelfLoop |

        CtBlock(0).Block.(Import.1 | Export.1 | Body.Region(0).1) |
        Node.(
            NodeType.Theta |
            Read.id |
            Import.id | ## Import
            Body.Region(0).id |
            Export.id  | ## Export
            Write.id |
            Extra.1
        )
    )
    @[0, 0, 2, 1, 1];

react rg_self_loop_connect_conditional = 
    Node.(
        NodeType.Theta |
        Read.id |
        Import.id | ## Import
        Body.Region(0).(
            Node.(
                Body.Br |
                Write.1 |
                id
            ) |
            id
        ) |
        Export.id  | ## Export
        Write.id
    )
    --> /x (
    Node.(
        NodeType.Theta |
        Read.id |
        Import.id | ## Import
        Body.Region(0).(
            Node.(
                Body.Br |
                Write.Dedge{x}.Branch |
                id
            ) |
            id
        ) |
        Export.(Dedge{x}.Branch | id)  | ## Export
        Write.id
    )
)
    ;


react rg_finish_node = 
    CtNode.(
        id |
        CtBlock(0).Block.(
            Body.Region(0).id |
            id
        ) |
        Node.id
    ) 
    -->
    Block.(
        Body.Region(0).(
            id | Node.id
        )
        | id
    )
    @[1, 3, 2];

react rg_lone_region_void = 
    Node.(
        NodeType.Lambda |
        Import.id |
        Body.Region(0).Ct.CtNode.(
            CtTopNode |
            CtBlock(0).Block.(
                Import.id |
                Body.Region(0).id |
                Export.id
            )
        ) |
        Export.1 |
        id
    )
    -->
    Node.(
        NodeType.Lambda |
        Import.(id | id) |
        Body.Region(0).id |
        Export.1 |
        id
    )
    @[0, 1, 2, 4]
    ;

react rg_lone_region_return = 
    Node.(
        NodeType.Lambda |
        Import.id |
        Body.Region(0).Ct.CtNode.(
            CtTopNode |
            CtBlock(0).Block.(
                Import.id |
                Body.Region(0).id |
                Export.(Dedge{x}.Loc{y} | id)
            )
        ) |
        Export.(/z Dedge{z}.Loc{y}) |
        id
    )
    -->
    Node.(
        NodeType.Lambda |
        Import.(id | id) |
        Body.Region(0).id |
        Export.Dedge{x}.Loc{y} |
        id
    )
    @[0, 1, 2, 4]
    ;

## Connect the Imports and Exports of the new Continuous Block
react rg_continuous_connect_state = 
    CtNode.(
        CtContinuous |
        CtBlock(1).Block.(
            Import.(Dedge{x}.State | id) |
            Export.(Dedge{y}.State | id) |
            id 
        ) |
        CtBlock(2).Block.(
            Import.(Dedge{w}.State | id) |
            Export.(Dedge{z}.State | id) |
            id
        ) | 
        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).id
        )
    ) 
    -->
    CtNode.(
        CtContinuous |
        CtBlock(1).Block.(
            Import.(Dedge{x}.State | id) |
            Export.id |
            id 
        ) |
        CtBlock(2).Block.(
            Import.id |
            Export.(Dedge{z}.State | id) |
            id
        ) | 
        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).(id | /u Alias{y,w}.AliasNewName{u})
        )
    )
    ;


react rg_continuous_connect_import_1_to_import_2 =  (
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Import.(Dedge{x}.Loc{y} | id) |
            id
        ) |
        CtBlock(2).Block.(
            Import.(Dedge{z}.Loc{y} | id) |
            id
        ) |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).id
        )
    )
)
    -->
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Import.(Dedge{x}.Loc{y} | id) |
            id
        ) |
        CtBlock(2).Block.(
            Import.id |
            id
        ) |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).(id | /u Alias{x,z}.AliasNewName{u})
        )
    )

    ;

react rg_continuous_connect_export_1_to_import_2 = 
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Export.(Dedge{x}.Loc{y} | id) |
            id
        ) |
        CtBlock(2).Block.(
            Import.(Dedge{z}.Loc{y} | id) |
            Export.id |
            id
        ) |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).id
        )
    )
    -->
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Export.id |
            id
        ) |
        CtBlock(2).Block.(
            Import.id |
            Export.(Dedge{z}.Loc{y} | id) |
            id
        ) |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).(id | /u Alias{x,z}.AliasNewName{u})
        )
    )

    ;

react rg_continuous_remove_export_1 =
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Export.(Dedge{x}.Loc{y} | id) |
            id
        ) |
        CtBlock(2).Block.(
            Export.(Dedge{z}.Loc{y} | id) |
            id
        ) |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).id
        )
    )
    -->
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Export.id |
            id
        ) |
        CtBlock(2).Block.(
            Export.(Dedge{z}.Loc{y} | id) |
            id
        ) |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).(id | /u Alias{x,z}.AliasNewName{u})
        )
    )
    ;

react rg_continuous_connect_export_1_to_import_2_remove_export_1 =
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Export.(Dedge{x}.Loc{y} | id) |
            id
        ) |
        CtBlock(2).Block.(
            Import.(Dedge{z}.Loc{y} | id) |
            Export.(Dedge{w}.Loc{y} | id) |
            id
        ) |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).id
        )
    )
    -->
    CtNode.(
        CtContinuous |

        CtBlock(1).Block.(
            Export.id |
            id
        ) |
        CtBlock(2).Block.(
            Import.id |
            Export.(Dedge{w}.Loc{y} | id) |
            id
        ) |

        Block.(
            Import.1 |
            Export.1 |
            Body.Region(0).(id | /u Alias{x,z}.AliasNewName{u})
        )
    ) 
    ;

## Aliasing fixes
react aliasing_connect = 
    Alias{x,y}.AliasNewName{u} || 
    Dedge{x}.id
    -->
    Alias{x,y}.AliasNewName{u} ||
    Dedge{u}.id
    ;

react aliasing_finish = /x /y
    Alias{x,y}.AliasNewName{u}
    -->
    1 | {u}
    ;

## Add the read and write of the new node
react rg_deduplicate_read = 
    Node.(
        Read.(Dedge{x}.Loc{y} | Dedge{z}.Loc{y} | id) |
        id
    )
    --> /w
    Node.(
        Read.(Dedge{w}.Loc{y} | id) |
        id |
        {x} | {z} 
    ) 
    ;

react rg_deduplicate_write = 
    Node.(
        Write.(Dedge{x}.Loc{y} | Dedge{z}.Loc{y} | id) |
        id
    )
    --> /w
    Node.(
        Write.(Dedge{w}.Loc{y} | id) |
        id |
        {x} | {z} 
    ) 
    ;

react rg_disconnect_dedge_read = ## Includes State
    Node.(
        Read.(Dedge{x}.id | id) |
        Import.(Dedge{x}.id | id) |
        id
    )
    --> /z
    Node.(
        Read.(Dedge{z}.id | id) |
        Import.(Dedge{x}.id | id) |
        id
    )
    ;

react rg_disconnect_dedge_write = ## includes State
    Node.(
        Write.(Dedge{x}.id | id) |
        Export.(Dedge{x}.id | id) |
        id
    )
    --> /z
    Node.(
        Write.(Dedge{z}.id | id) |
        Export.(Dedge{x}.id | id) |
        id
    )
    ;

react rg_deduplicate_state_read = /x /y
    Read.(Dedge{x}.State | Dedge{y}.State | id)
    --> /x
    Read.(Dedge{x}.State | id)
    ;

react rg_deduplicate_state_write = /x /y
    Write.(Dedge{x}.State | Dedge{y}.State | id)
    --> /x
    Write.(Dedge{x}.State | id)
    ;
    
    
## Incorporate the new node into its parent node
## # Connect the Read and Write of the new node

react rg_connect_node_read_to_export = /z (
    CtBlock(0).Block.(
        Export.(
            Dedge{x}.Loc{y} | 
            id
        ) |
        id
    ) | 
    Node.(
        Read.(
            Dedge{z}.Loc{y} | 
            id
        ) |
        id
    )
)
    --> (
    CtBlock(0).Block.(
        Export.(
            Dedge{x}.Loc{y} | 
            id
        ) |
        id
    ) | 
    Node.(
        Read.(
            Dedge{x}.Loc{y} | 
            id
        ) |
        id
    )
)
    ;

react rg_connect_write_to_export = /z (
    CtBlock(0).Block.(
        Export.(
            Dedge{x}.Loc{y} | id
        ) |
        id
    ) | 
    Node.(
        Write.(
            Dedge{z}.Loc{y} | 
            id
        ) |
        id
    )
)
    -->  /z (
    CtBlock(0).Block.(
        Export.(
            Dedge{z}.Loc{y} | id
        ) |
        id
    ) |
    Node.(
        Write.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    ) | {x}
)
    ;


react rg_connect_read_to_import = /z (
    CtBlock(0).Block.(
        Import.(
            Dedge{x}.Loc{y} | id
        ) | 
        id
    ) |
    Node.(
        Read.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    )
)
    -->
    CtBlock(0).Block.(
        Import.(
            Dedge{x}.Loc{y} | id
        ) | 
        id
    ) |
    Node.(
        Read.(
            Dedge{x}.Loc{y} | id
        ) |
        id
    )
    ;

react rg_add_write_to_export = /z (
    CtBlock(0).Block.(
        Export.id |
        id
    ) |
    Node.(
        Write.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    )
)
    --> /z (
    CtBlock(0).Block.(
        Export.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    ) | 
    Node.(
        Write.(
            Dedge{z}.Loc{y} | id
        ) |
        id
    )
)
    ## if !{y} in param
    ;

react rg_add_read_to_import = /z (
    CtBlock(0).Block.(
        Import.id |
        id
    ) |
    Node.(
        Read.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    )
)
    --> /z (
    CtBlock(0).Block.(
        Import.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    ) | 
    Node.(
        Read.(
            Dedge{z}.Loc{y} | id
        ) |
        id
    )
)
    ## if !{y} in param
    ;

react rg_connect_state = /z /w (
    CtBlock(0).Block.(
        Import.(
            Dedge{x}.State | id
        ) | 
        Export.(
            Dedge{y}.State | id
        ) | 
        id
    ) |
    Node.(
        Read.(
            Dedge{z}.State | id
        ) | 
        Write.(
            Dedge{w}.State | id
        ) |
        id
    )
)
    --> /v (
    CtBlock(0).Block.(
        Import.(
            Dedge{x}.State | id
        ) | 
        Export.(
            Dedge{v}.State | id
        ) | 
        id
    ) |
    Node.(
        Read.(
            Dedge{y}.State | id
        ) | 
        Write.(
            Dedge{v}.State | id
        ) |
        id
    )
)
    ;

react rg_add_state = (
    CtBlock(0).Block.(
        Import.id |
        Export.id |
        id
    ) |
    Node.(
        Read.(
            Dedge{x}.State | id
        ) |
        Write.(
            Dedge{y}.State | id 
        ) |
        id
    )
)
    --> /z /w (
    CtBlock(0).Block.(
        Import.(
            Dedge{z}.State | id 
        ) | 
        Export.(
            Dedge{w}.State | id 
        ) |
        id 
    ) |
    Node.(
        Read.(
            Dedge{z}.State | id
        ) |
        Write.(
            Dedge{w}.State | id 
        ) |
        id | {x} | {y}
    )
)
    if !State in param;

## Disconnect created node from the import/export
react rg_disconnect_loc_new_node = 
    CtBlock(0).Block.(
        Import.(Dedge{z}.Loc{y} | id) | 
        Export.(Dedge{w}.Loc{y} | id) |
        id
    ) | 
    Node.(
        Read.(Dedge{z}.Loc{y} | id) |
        Import.(Dedge{a}.Loc{y} | id) |
        Export.(Dedge{b}.Loc{y} | id) |
        Write.(Dedge{w}.Loc{y} | id) |
        id
    )
    --> /n (
        CtBlock(0).Block.(
        Import.(Dedge{z}.Loc{y} | id) | 
        Export.(Dedge{w}.Loc{y} | id) |
        id
    ) | 
    Node.(
        Read.(Dedge{z}.Loc{n} | id) |
        Import.(Dedge{a}.Loc{n} | id) |
        Export.(Dedge{b}.Loc{n} | id) |
        Write.(Dedge{w}.Loc{n} | id) |
        id
    )
)
    ;

react rg_disconnect_loc_new_node_import = 
    CtBlock(0).Block.(
        Import.(Dedge{z}.Loc{y} | id) |
        id
    ) | 
    Node.(
        Read.(Dedge{z}.Loc{y} | id) |
        Import.(Dedge{a}.Loc{y} | id) |
        id
    )
    --> /n (
        CtBlock(0).Block.(
        Import.(Dedge{z}.Loc{y} | id) | 
        id
    ) | 
    Node.(
        Read.(Dedge{z}.Loc{n} | id) |
        Import.(Dedge{a}.Loc{n} | id) |
        id
    )
)
    ;

react rg_disconnect_loc_new_node_export = 
    CtBlock(0).Block.(
        Export.(Dedge{w}.Loc{y} | id) |
        id
    ) | 
    Node.(
        Export.(Dedge{b}.Loc{y} | id) |
        Write.(Dedge{w}.Loc{y} | id) |
        id
    )
    --> /n (
        CtBlock(0).Block.(
        Export.(Dedge{w}.Loc{y} | id) |
        id
    ) | 
    Node.(
        Export.(Dedge{b}.Loc{n} | id) |
        Write.(Dedge{w}.Loc{n} | id) |
        id
    )
)
    ;
    






