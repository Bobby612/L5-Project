

## Transform Control Flow Graph to Control Tree
react ct_begin = 
    Node.(
        NodeType.Lambda |
        Body.Region(0).( ## Function is non-empty and has CFG in it
            Block.id | id
        ) |
        id
    )   
    -->
    Node.(
        NodeType.Lambda |
        Body.Region(0).( 
            Block.id | id | Ct.1
        ) |
        id
    )
    if !Ct in param
    ;

react ct_continuous = /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{y} 
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            id
        ) |
        id
    ) |
    Ct.id 
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            id
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtContinuous |

            CtBlock(1).Block.id |
            CtBlock(2).Block.id |

            CtAbstract{a}
        ) |
        id
    ) 
)
    @[1, 0, 2, 3];

react ct_if_then_else = /y /z (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(1){y} | BlockExit_ord(2){z}
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{w} 
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{z} |
            BlockExit{w} 
        ) |
        id
    ) |
    Ct.id 
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{w} 
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtIfThenElse |

            CtBlock(0).Block.id |
            CtBlock(1).Block.id |
            CtBlock(2).Block.id |
            
            CtAbstract{a}
        ) |
        id
    ) 
)
    ;

fun react ct_if_then(i, j) = /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){y} | BlockExit_ord(j){z}
        ) |
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{z}
        ) |
        id
    ) |
    Ct.id
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{z}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtIfThen |
            CtBlock(0).Block.id |
            CtBlock(1).Block.id |
            CtAbstract{a}
        ) |
        id
    )
)
    ;

fun react ct_selfloop(i, j) = ## The self-loop can be either the first or the second exit
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){x} | BlockExit_ord(j){y}
        ) |
        id
    ) |
    Ct.id
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} | BlockExit{y}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtSelfLoop |

            CtBlock(0).Block.id |
            
            CtAbstract{a}
        ) |
        id
    ) 
)
    ;

fun react ct_while_loop(i, j) =  /y (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit_ord(i){y} | BlockExit_ord(j){z}
        ) | 
        id
    ) |
    Block.(
        Interface.(
            BlockEntry{y} |
            BlockExit{x}
        ) |
        id
    ) |
    Ct.id
)
    --> /a (
    Block.(
        Interface.(
            BlockEntry{x} |
            BlockExit{z}
        ) |
        CtAbstract{a}
    ) |
    Ct.(
        CtNode.(
            CtWhileLoop |
            
            CtBlock(0).Block.id |
            CtBlock(1).Block.id |

            CtAbstract{a}
        ) |
        id
    )
)
    ;

react ct_top_node = /x (
    Block.(
        Interface.BlockEntry{x} | 
        id
    ) | 
    Ct.id
)
    -->
    1 |
    Ct.(
        CtNode.(
            CtTopNode |
            CtBlock(0).Block.id
        ) | 
        id
    )
    ;

fun react ct_deabstractify(i) = /a (
    CtNode.(
        CtBlock(i).Block.CtAbstract{a} |
        id
    ) ||
    CtNode.(
        id |
        CtAbstract{a}
    )
)
    -->
    CtNode.(
        id |
        CtBlock(i).CtNode.id
    ) ||
    1
    ;


## Transform the Control Tree to RVSDG
    react rg_if_then_else = 
    CtNode.(
        CtIfThenElse |

        CtBlock(0).Block.id |
        CtBlock(1).Block.(Import.id | Export.id | Body.id) |
        CtBlock(2).Block.(Import.id | Export.id | Body.id) 
    )
    -->
    CtNode.(
        CtIfThenElse |

        CtBlock(0).Block.id |
        Node.(
            NodeType.Gamma |
            Read.(id | id) |
            Import.id | Import.id | ## Import
            Body.(
                id | id
            ) |
            Export.id | Export.id  | ## Export
            Write.(id | id)
        )
    )
    @[0, 1, 4, 1, 4, 3, 6, 2, 5, 2, 5]
    if !CtNode in param
    ;

react rg_finish_node = 
    CtNode.(
        id |
        CtBlock(0).Block.(
            Body.Region(0).id |
            id
        ) |
        Node.id
    ) 
    -->
    Block.(
        Body.Region(0).(
            id | Node.id
        )
        | id
    )
    @[1, 2, 3];


## Add the read and write of the new node
react rg_deduplicate_read = 
    Node.(
        Read.(Dedge{x}.Loc{y} | Dedge{z}.Loc{y} | id) |
        id
    )
    --> /w
    Node.(
        Read.(Dedge{w}.Loc{y} | id) |
        id |
        {x} | {z} 
    ) 
    ;

react rg_deduplicate_write = 
    Node.(
        Write.(Dedge{x}.Loc{y} | Dedge{z}.Loc{y} | id) |
        id
    )
    --> /w
    Node.(
        Write.(Dedge{w}.Loc{y} | id) |
        id |
        {x} | {z} 
    ) 
    ;

react rg_disconnect_dedge_read = ## Includes State
    Node.(
        Read.(Dedge{x}.id | id) |
        Import.(Dedge{x}.id | id) |
        id
    )
    --> /z
    Node.(
        Read.(Dedge{z}.id | id) |
        Import.(Dedge{x}.id | id) |
        id
    )
    ;

react rg_disconnect_dedge_write = ## includes State
    Node.(
        Write.(Dedge{x}.id | id) |
        Export.(Dedge{x}.id | id) |
        id
    )
    --> /z
    Node.(
        Write.(Dedge{z}.id | id) |
        Export.(Dedge{x} | id) |
        id
    )
    ;

react rg_deduplicate_state_read = /x /y
    Read.(Dedge{x}.State | Dedge{y}.State | id)
    --> /x
    Read.(Dedge{x}.State | id)
    ;

react rg_deduplicate_state_write = /x /y
    Write.(Dedge{x}.State | Dedge{y}.State | id)
    --> /x
    Write.(Dedge{x}.State | id)
    ;
    
    
## Incorporate the new node into its parent node
## # Connect the Read and Write of the new node

react rg_connect_node_read_to_export = /z (
    CtBlock(0).Block.(
        Export.(
            Dedge{x}.Loc{y} | id
        ) |
        id
    ) | 
    Node.(
        Read.(
            Dedge{z}.Loc{y} | 
            id
        ) |
        id
    )
)
    --> (
    CtBlock(0).Block.(
        Export.(
            Dedge{x}.Loc{y} |id
        ) |
        id
    ) | 
    Node.(
        Read.(
            Dedge{x}.Loc{y} | 
            id
        ) |
        id
    )
)
    ;

react rg_connect_write_to_export = /z (
    CtBlock(0).Block.(
        Export.(
            Dedge{x}.Loc{y} | id
        ) |
        id
    ) | 
    Node.(
        Write.(
            Dedge{z}.Loc{y} | 
            id
        ) |
        id
    )
)
    -->  /z (
    CtBlock(0).Block.(
        Export.(
            Dedge{z}.Loc{y} | id
        ) |
        id
    ) |
    Node.(
        Write.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    ) | {x}
)
    ;


react rg_connect_read_to_import = /z (
    CtBlock(0).Block.(
        Import.(
            Dedge{x}.Loc{y} | id
        ) | 
        id
    ) |
    Node.(
        Read.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    )
)
    -->
    CtBlock(0).Block.(
        Import.(
            Dedge{x}.Loc{y} | id
        ) | 
        id
    ) |
    Node.(
        Read.(
            Dedge{x}.Loc{y} | id
        ) |
        id
    )
    ;

react rg_add_write_to_export = /z (
    CtBlock(0).Block.(
        Export.id |
        id
    ) |
    Node.(
        Write.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    )
)
    --> /z (
    CtBlock(0).Block.(
        Export.(
            Dedge{z}.Loc{y} | id
        ) | 
        id
    ) | 
    Node.(
        Write.(
            Dedge{z}.Loc{y} | id
        ) |
        id
    )
)
    if !{y} in param;

react rg_connect_state = /z /w (
    CtBlock(0).Block.(
        Import.(
            Dedge{x}.State | id
        ) | 
        Export.(
            Dedge{y}.State | id
        ) | 
        id
    ) |
    Node.(
        Read.(
            Dedge{z}.State | id
        ) | 
        Write.(
            Dedge{w}.State | id
        ) |
        id
    )
)
    --> /v (
    CtBlock(0).Block.(
        Import.(
            Dedge{x}.State | id
        ) | 
        Export.(
            Dedge{v}.State | id
        ) | 
        id
    ) |
    Node.(
        Read.(
            Dedge{y}.State | id
        ) | 
        Write.(
            Dedge{v}.State | id
        ) |
        id
    )
)
    ;

react rg_add_state = (
    CtBlock(0).Block.(
        Import.id |
        Export.id |
        id
    ) |
    Node.(
        Read.(
            Dedge{x}.State | id
        ) |
        Write.(
            Dedge{y}.State | id 
        ) |
        id
    )
)
    --> /z /w (
    CtBlock(0).Block.(
        Import.(
            Dedge{z}.State | id 
        ) | 
        Export.(
            Dedge{w}.State | id 
        ) |
        id 
    ) |
    Node.(
        Read.(
            Dedge{z}.State | id
        ) |
        Write.(
            Dedge{w}.State | id 
        ) |
        id | {x} | {y}
    )
)
    if !State in param;
    






